// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.
// Code generated by gorm.io/gen. DO NOT EDIT.

package dao

import (
	"context"

	"gorm.io/gorm"
	"gorm.io/gorm/clause"
	"gorm.io/gorm/schema"

	"gorm.io/gen"
	"gorm.io/gen/field"

	"gorm.io/plugin/dbresolver"

	"code.pypygo.com/vertex/ollie/apps/account/dao/model"
)

func newTBuildService(db *gorm.DB, opts ...gen.DOOption) tBuildService {
	_tBuildService := tBuildService{}

	_tBuildService.tBuildServiceDo.UseDB(db, opts...)
	_tBuildService.tBuildServiceDo.UseModel(&model.TBuildService{})

	tableName := _tBuildService.tBuildServiceDo.TableName()
	_tBuildService.ALL = field.NewAsterisk(tableName)
	_tBuildService.ID = field.NewInt64(tableName, "id")
	_tBuildService.SvcName = field.NewString(tableName, "svc_name")
	_tBuildService.Version = field.NewString(tableName, "version")
	_tBuildService.ImageTag = field.NewString(tableName, "image_tag")
	_tBuildService.BranchName = field.NewString(tableName, "branch_name")
	_tBuildService.BuildCommit = field.NewString(tableName, "build_commit")
	_tBuildService.CiEndType = field.NewInt32(tableName, "ci_end_type")
	_tBuildService.MonoName = field.NewString(tableName, "mono_name")
	_tBuildService.CreateAt = field.NewInt64(tableName, "create_at")
	_tBuildService.UpdateAt = field.NewInt64(tableName, "update_at")
	_tBuildService.DeleteAt = field.NewInt64(tableName, "delete_at")

	_tBuildService.fillFieldMap()

	return _tBuildService
}

type tBuildService struct {
	tBuildServiceDo

	ALL         field.Asterisk
	ID          field.Int64
	SvcName     field.String // gitlab构建的服务名称
	Version     field.String // gitlab构建服务的vX.Y.Z版本
	ImageTag    field.String // gitlab构建服务的当前commit short hash 作为image tag
	BranchName  field.String // gitlab构建服务的当前发布分支名称，hotfix/release vX.Y.Z
	BuildCommit field.String // gitlab构建服务的当前commit完整hash
	CiEndType   field.Int32  // 该构建服务属于前端还是后端，前端可能走cdn，作为区分处理
	MonoName    field.String // 该服务的仓库类型,可null，大仓时存在 会平铺成多条记录，存在N:1关系
	CreateAt    field.Int64
	UpdateAt    field.Int64
	DeleteAt    field.Int64

	fieldMap map[string]field.Expr
}

func (t tBuildService) Table(newTableName string) *tBuildService {
	t.tBuildServiceDo.UseTable(newTableName)
	return t.updateTableName(newTableName)
}

func (t tBuildService) As(alias string) *tBuildService {
	t.tBuildServiceDo.DO = *(t.tBuildServiceDo.As(alias).(*gen.DO))
	return t.updateTableName(alias)
}

func (t *tBuildService) updateTableName(table string) *tBuildService {
	t.ALL = field.NewAsterisk(table)
	t.ID = field.NewInt64(table, "id")
	t.SvcName = field.NewString(table, "svc_name")
	t.Version = field.NewString(table, "version")
	t.ImageTag = field.NewString(table, "image_tag")
	t.BranchName = field.NewString(table, "branch_name")
	t.BuildCommit = field.NewString(table, "build_commit")
	t.CiEndType = field.NewInt32(table, "ci_end_type")
	t.MonoName = field.NewString(table, "mono_name")
	t.CreateAt = field.NewInt64(table, "create_at")
	t.UpdateAt = field.NewInt64(table, "update_at")
	t.DeleteAt = field.NewInt64(table, "delete_at")

	t.fillFieldMap()

	return t
}

func (t *tBuildService) GetFieldByName(fieldName string) (field.OrderExpr, bool) {
	_f, ok := t.fieldMap[fieldName]
	if !ok || _f == nil {
		return nil, false
	}
	_oe, ok := _f.(field.OrderExpr)
	return _oe, ok
}

func (t *tBuildService) fillFieldMap() {
	t.fieldMap = make(map[string]field.Expr, 11)
	t.fieldMap["id"] = t.ID
	t.fieldMap["svc_name"] = t.SvcName
	t.fieldMap["version"] = t.Version
	t.fieldMap["image_tag"] = t.ImageTag
	t.fieldMap["branch_name"] = t.BranchName
	t.fieldMap["build_commit"] = t.BuildCommit
	t.fieldMap["ci_end_type"] = t.CiEndType
	t.fieldMap["mono_name"] = t.MonoName
	t.fieldMap["create_at"] = t.CreateAt
	t.fieldMap["update_at"] = t.UpdateAt
	t.fieldMap["delete_at"] = t.DeleteAt
}

func (t tBuildService) clone(db *gorm.DB) tBuildService {
	t.tBuildServiceDo.ReplaceConnPool(db.Statement.ConnPool)
	return t
}

func (t tBuildService) replaceDB(db *gorm.DB) tBuildService {
	t.tBuildServiceDo.ReplaceDB(db)
	return t
}

type tBuildServiceDo struct{ gen.DO }

type ITBuildServiceDo interface {
	gen.SubQuery
	Debug() ITBuildServiceDo
	WithContext(ctx context.Context) ITBuildServiceDo
	WithResult(fc func(tx gen.Dao)) gen.ResultInfo
	ReplaceDB(db *gorm.DB)
	ReadDB() ITBuildServiceDo
	WriteDB() ITBuildServiceDo
	As(alias string) gen.Dao
	Session(config *gorm.Session) ITBuildServiceDo
	Columns(cols ...field.Expr) gen.Columns
	Clauses(conds ...clause.Expression) ITBuildServiceDo
	Not(conds ...gen.Condition) ITBuildServiceDo
	Or(conds ...gen.Condition) ITBuildServiceDo
	Select(conds ...field.Expr) ITBuildServiceDo
	Where(conds ...gen.Condition) ITBuildServiceDo
	Order(conds ...field.Expr) ITBuildServiceDo
	Distinct(cols ...field.Expr) ITBuildServiceDo
	Omit(cols ...field.Expr) ITBuildServiceDo
	Join(table schema.Tabler, on ...field.Expr) ITBuildServiceDo
	LeftJoin(table schema.Tabler, on ...field.Expr) ITBuildServiceDo
	RightJoin(table schema.Tabler, on ...field.Expr) ITBuildServiceDo
	Group(cols ...field.Expr) ITBuildServiceDo
	Having(conds ...gen.Condition) ITBuildServiceDo
	Limit(limit int) ITBuildServiceDo
	Offset(offset int) ITBuildServiceDo
	Count() (count int64, err error)
	Scopes(funcs ...func(gen.Dao) gen.Dao) ITBuildServiceDo
	Unscoped() ITBuildServiceDo
	Create(values ...*model.TBuildService) error
	CreateInBatches(values []*model.TBuildService, batchSize int) error
	Save(values ...*model.TBuildService) error
	First() (*model.TBuildService, error)
	Take() (*model.TBuildService, error)
	Last() (*model.TBuildService, error)
	Find() ([]*model.TBuildService, error)
	FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TBuildService, err error)
	FindInBatches(result *[]*model.TBuildService, batchSize int, fc func(tx gen.Dao, batch int) error) error
	Pluck(column field.Expr, dest interface{}) error
	Delete(...*model.TBuildService) (info gen.ResultInfo, err error)
	Update(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	Updates(value interface{}) (info gen.ResultInfo, err error)
	UpdateColumn(column field.Expr, value interface{}) (info gen.ResultInfo, err error)
	UpdateColumnSimple(columns ...field.AssignExpr) (info gen.ResultInfo, err error)
	UpdateColumns(value interface{}) (info gen.ResultInfo, err error)
	UpdateFrom(q gen.SubQuery) gen.Dao
	Attrs(attrs ...field.AssignExpr) ITBuildServiceDo
	Assign(attrs ...field.AssignExpr) ITBuildServiceDo
	Joins(fields ...field.RelationField) ITBuildServiceDo
	Preload(fields ...field.RelationField) ITBuildServiceDo
	FirstOrInit() (*model.TBuildService, error)
	FirstOrCreate() (*model.TBuildService, error)
	FindByPage(offset int, limit int) (result []*model.TBuildService, count int64, err error)
	ScanByPage(result interface{}, offset int, limit int) (count int64, err error)
	Scan(result interface{}) (err error)
	Returning(value interface{}, columns ...string) ITBuildServiceDo
	UnderlyingDB() *gorm.DB
	schema.Tabler
}

func (t tBuildServiceDo) Debug() ITBuildServiceDo {
	return t.withDO(t.DO.Debug())
}

func (t tBuildServiceDo) WithContext(ctx context.Context) ITBuildServiceDo {
	return t.withDO(t.DO.WithContext(ctx))
}

func (t tBuildServiceDo) ReadDB() ITBuildServiceDo {
	return t.Clauses(dbresolver.Read)
}

func (t tBuildServiceDo) WriteDB() ITBuildServiceDo {
	return t.Clauses(dbresolver.Write)
}

func (t tBuildServiceDo) Session(config *gorm.Session) ITBuildServiceDo {
	return t.withDO(t.DO.Session(config))
}

func (t tBuildServiceDo) Clauses(conds ...clause.Expression) ITBuildServiceDo {
	return t.withDO(t.DO.Clauses(conds...))
}

func (t tBuildServiceDo) Returning(value interface{}, columns ...string) ITBuildServiceDo {
	return t.withDO(t.DO.Returning(value, columns...))
}

func (t tBuildServiceDo) Not(conds ...gen.Condition) ITBuildServiceDo {
	return t.withDO(t.DO.Not(conds...))
}

func (t tBuildServiceDo) Or(conds ...gen.Condition) ITBuildServiceDo {
	return t.withDO(t.DO.Or(conds...))
}

func (t tBuildServiceDo) Select(conds ...field.Expr) ITBuildServiceDo {
	return t.withDO(t.DO.Select(conds...))
}

func (t tBuildServiceDo) Where(conds ...gen.Condition) ITBuildServiceDo {
	return t.withDO(t.DO.Where(conds...))
}

func (t tBuildServiceDo) Order(conds ...field.Expr) ITBuildServiceDo {
	return t.withDO(t.DO.Order(conds...))
}

func (t tBuildServiceDo) Distinct(cols ...field.Expr) ITBuildServiceDo {
	return t.withDO(t.DO.Distinct(cols...))
}

func (t tBuildServiceDo) Omit(cols ...field.Expr) ITBuildServiceDo {
	return t.withDO(t.DO.Omit(cols...))
}

func (t tBuildServiceDo) Join(table schema.Tabler, on ...field.Expr) ITBuildServiceDo {
	return t.withDO(t.DO.Join(table, on...))
}

func (t tBuildServiceDo) LeftJoin(table schema.Tabler, on ...field.Expr) ITBuildServiceDo {
	return t.withDO(t.DO.LeftJoin(table, on...))
}

func (t tBuildServiceDo) RightJoin(table schema.Tabler, on ...field.Expr) ITBuildServiceDo {
	return t.withDO(t.DO.RightJoin(table, on...))
}

func (t tBuildServiceDo) Group(cols ...field.Expr) ITBuildServiceDo {
	return t.withDO(t.DO.Group(cols...))
}

func (t tBuildServiceDo) Having(conds ...gen.Condition) ITBuildServiceDo {
	return t.withDO(t.DO.Having(conds...))
}

func (t tBuildServiceDo) Limit(limit int) ITBuildServiceDo {
	return t.withDO(t.DO.Limit(limit))
}

func (t tBuildServiceDo) Offset(offset int) ITBuildServiceDo {
	return t.withDO(t.DO.Offset(offset))
}

func (t tBuildServiceDo) Scopes(funcs ...func(gen.Dao) gen.Dao) ITBuildServiceDo {
	return t.withDO(t.DO.Scopes(funcs...))
}

func (t tBuildServiceDo) Unscoped() ITBuildServiceDo {
	return t.withDO(t.DO.Unscoped())
}

func (t tBuildServiceDo) Create(values ...*model.TBuildService) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Create(values)
}

func (t tBuildServiceDo) CreateInBatches(values []*model.TBuildService, batchSize int) error {
	return t.DO.CreateInBatches(values, batchSize)
}

// Save : !!! underlying implementation is different with GORM
// The method is equivalent to executing the statement: db.Clauses(clause.OnConflict{UpdateAll: true}).Create(values)
func (t tBuildServiceDo) Save(values ...*model.TBuildService) error {
	if len(values) == 0 {
		return nil
	}
	return t.DO.Save(values)
}

func (t tBuildServiceDo) First() (*model.TBuildService, error) {
	if result, err := t.DO.First(); err != nil {
		return nil, err
	} else {
		return result.(*model.TBuildService), nil
	}
}

func (t tBuildServiceDo) Take() (*model.TBuildService, error) {
	if result, err := t.DO.Take(); err != nil {
		return nil, err
	} else {
		return result.(*model.TBuildService), nil
	}
}

func (t tBuildServiceDo) Last() (*model.TBuildService, error) {
	if result, err := t.DO.Last(); err != nil {
		return nil, err
	} else {
		return result.(*model.TBuildService), nil
	}
}

func (t tBuildServiceDo) Find() ([]*model.TBuildService, error) {
	result, err := t.DO.Find()
	return result.([]*model.TBuildService), err
}

func (t tBuildServiceDo) FindInBatch(batchSize int, fc func(tx gen.Dao, batch int) error) (results []*model.TBuildService, err error) {
	buf := make([]*model.TBuildService, 0, batchSize)
	err = t.DO.FindInBatches(&buf, batchSize, func(tx gen.Dao, batch int) error {
		defer func() { results = append(results, buf...) }()
		return fc(tx, batch)
	})
	return results, err
}

func (t tBuildServiceDo) FindInBatches(result *[]*model.TBuildService, batchSize int, fc func(tx gen.Dao, batch int) error) error {
	return t.DO.FindInBatches(result, batchSize, fc)
}

func (t tBuildServiceDo) Attrs(attrs ...field.AssignExpr) ITBuildServiceDo {
	return t.withDO(t.DO.Attrs(attrs...))
}

func (t tBuildServiceDo) Assign(attrs ...field.AssignExpr) ITBuildServiceDo {
	return t.withDO(t.DO.Assign(attrs...))
}

func (t tBuildServiceDo) Joins(fields ...field.RelationField) ITBuildServiceDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Joins(_f))
	}
	return &t
}

func (t tBuildServiceDo) Preload(fields ...field.RelationField) ITBuildServiceDo {
	for _, _f := range fields {
		t = *t.withDO(t.DO.Preload(_f))
	}
	return &t
}

func (t tBuildServiceDo) FirstOrInit() (*model.TBuildService, error) {
	if result, err := t.DO.FirstOrInit(); err != nil {
		return nil, err
	} else {
		return result.(*model.TBuildService), nil
	}
}

func (t tBuildServiceDo) FirstOrCreate() (*model.TBuildService, error) {
	if result, err := t.DO.FirstOrCreate(); err != nil {
		return nil, err
	} else {
		return result.(*model.TBuildService), nil
	}
}

func (t tBuildServiceDo) FindByPage(offset int, limit int) (result []*model.TBuildService, count int64, err error) {
	result, err = t.Offset(offset).Limit(limit).Find()
	if err != nil {
		return
	}

	if size := len(result); 0 < limit && 0 < size && size < limit {
		count = int64(size + offset)
		return
	}

	count, err = t.Offset(-1).Limit(-1).Count()
	return
}

func (t tBuildServiceDo) ScanByPage(result interface{}, offset int, limit int) (count int64, err error) {
	count, err = t.Count()
	if err != nil {
		return
	}

	err = t.Offset(offset).Limit(limit).Scan(result)
	return
}

func (t tBuildServiceDo) Scan(result interface{}) (err error) {
	return t.DO.Scan(result)
}

func (t tBuildServiceDo) Delete(models ...*model.TBuildService) (result gen.ResultInfo, err error) {
	return t.DO.Delete(models)
}

func (t *tBuildServiceDo) withDO(do gen.Dao) *tBuildServiceDo {
	t.DO = *do.(*gen.DO)
	return t
}
